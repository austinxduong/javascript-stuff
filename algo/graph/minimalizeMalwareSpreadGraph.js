console.log("malware disjointed sets graph data structure file has been generated")
// expensive algorithm

class DSU {
    constructor(size, components) {
        this.components = components || Array(size).fill(-1)
    }

    // methods

    find(node){
        if (this.components[node] < 0) {
            return node
        }
        return this.find(this.components[node])
    }


    
    union(node1, node2){
        const parentNode1 = this.find(node1)
        const parentNode2 = this.find(node2)
        if (parentNode1 !== parentNode2) {
            const sizeOfNode2Component = this.components[parentNode2]
            this.components[parentNode1] += sizeOfNode2Component
            this.components[parentNode2] = parentNode1
        }

    }

}

function minimalizeMalwareSpread(network, initiallyInfected) {
    const networkSize = network.length
    const networkDSU = new DSU(networkSize)

    // adding in our "clean nodes" (components) to a DSU
    for (let i = 0; i < networkSize; i++) {  // looping through the each node in the array
        if(initiallyInfected.indexOf(i) > - 1) continue
        const connections = network[i] 

        for(let j = 0; j < connections.length; j++) { // looping through each connection in the sub array
            if (initiallyInfected.indexOf(j) > -1) continue
            if (connections[j]) {
                networkDSU.union(i, j) // call union between non-initially infected nodes
            }
        }
    }
    
    // copy of network DSU with pre existing components
    // adding one by one, of each initially infected nodes

    console.log('cleanstate', networkDSU.components)
    const cleanState = networkDSU.components
    let worstSize = 0; // how many components will be infected, if the initially infected nodes becomes the parent
    let worstNode = null; // which initially infected node, would infect the most components

    for (let i = 0; i < initiallyInfected.length; i++) {
        const freshDSU = new DSU(networkSize, cleanState)
        const infectedNode = initiallyInfected[i]
        const connections = network[infectedNode] // loops through the subarray (infected node), and all of its connections
        for (let j = 0; j < connections.length; j++) { // ^^^^^^^^
            if (initiallyInfected.indexOf(j) > -1) continue
            if (connections[j]) {
                freshDSU.union(infectedNode, j) // unionize the infected node, to all of the non infected node (make initialy infected node the parent of all non-infected nodes)
            } 
        }

    console.log(`after infecting the network with ${infectedNode}`,freshDSU.components)

    // oppurtunity check size of component created from
    // adding in the infected node
    if (freshDSU.components[infectedNode] < worstSize) {
        worstNode = infectedNode
        }
        worstSize = Math.min(worstSize, freshDSU.components[infectedNode])
    }
    return worstNode
    console.log(networkDSU.components)
}

// console.log(minimalizeMalwareSpread([[0, 1, 0], [1, 0, 1], [0, 1, 0]], [0, 1])) // 1
// console.log(minimalizeMalwareSpread([[0, 1, 1], [ 1, 0, 0], [1, 0, 0]], [0, 1])) // 0
console.log(minimalizeMalwareSpread([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], [0, 1])) // 1


// time complexity -- O(n^2)
// space complexity -- O(n * m)